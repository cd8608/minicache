#!/usr/bin/python
from pylibs.common import *
import numpy as np
import matplotlib
matplotlib.use("Agg") # no GUI output
import matplotlib.pyplot as plt
import matplotlib.ticker as mt
import matplotlib.cm as cm
import matplotlib.colors as colors
import matplotlib.font_manager as fp
from mpl_toolkits.mplot3d.axes3d import Axes3D
from scipy import stats

def dps2bitps(dps, blkdata_per_pkt=1024., pkt_encap_len=42.):
    if dps == 0:
        return 0
    return (dps / blkdata_per_pkt) * ((pkt_encap_len + blkdata_per_pkt) * 8)

markers = ( '^', 's', 'o', 'D', 'x', '*', '|', 'h' )
colors = ('#ccecff', '#99b1bf', '#667680', '#282e32') # bgray
#colors = ('#ffffff', '#c0c0c0', '#808080', '#202020')
#colors = ('b', 'g', 'r', 'c', 'm', 'y', 'k')
hatches = ('/', '\\', 'x', '-', '.', 'O', ' ')
skip_nb_initial_msmnts = 0
# BAR settings
bwidth = 1

##
## MAIN
##

printf("Loading file '%s'...\n", sys.argv[1])
## Load file into result, columns are:
#  [0] DISK-ID*
#  [1] INDIRECT MODE?*
#  [2] BLOCK SIZE*
#  [3] PACKET SIZE (ethernet frame size without preamble)**
#  [4] PACKETS PER BLOCK**
#  [5] PACKET: HEADER LENGTH**
#  [6] PACKET: BLOCK DATA LENGTH**
#  [7] PACKET: ADDITIONAL PAYLOAD LENGTH*
#  [8] PACKET: UDP CHECKSUM*
# ---
#  [9] NUMBER OF READ BLOCKS***
# [10] NUMBER OF SENT PACKETS***
# [11] INTERVAL LENGTH***
# [12] TIMESTAMP***
# <..> optional fields (not handled by this script)
#
# *) settings
# **) resulting properties (dependent on settings)
# ***) measurement values
result = np.genfromtxt(sys.argv[1], delimiter=";", skip_header=True)

# Collect test settings
test_disks = np.unique(result.T[0])
test_modes = np.unique(result.T[1])
test_blksizes = np.unique(result.T[2])
test_apayloads = np.unique(result.T[7])
test_chksums = np.unique(result.T[8])
min_ts = np.min(result.T[12])
nb_disks = len(test_disks)
nb_modes = len(test_modes)
nb_blksizes = len(test_blksizes)
nb_apayloads = len(test_apayloads)
nb_chksums = len(test_chksums)

# create plot
fig = plt.figure()
ax = plt.subplot(111)
ax.xaxis.set_ticks([]) # remove x-axis labels
ax.set_ylabel("Block data throughput")
ax.yaxis.set_major_formatter(HumanReadableFormatter("B/s", infix="i", multiple=1024))
ax2 = ax.twinx() # create twin plot
ax2.set_ylabel("Bits per second")
ax2.yaxis.set_major_formatter(HumanReadableFormatter("b/s"))
ax2.xaxis.set_ticks([]) # remove x-axis labels

# plot loop
d = 0
printf("Plotting...")
for i_disk in range(0, nb_disks):
    disk = test_disks[i_disk]
    _st0 = subtable_where(result, 0, "==", disk)
    for i_mode in range(0, nb_modes):
        mode = test_modes[i_mode]
	_st1 = subtable_where(_st0, 1, "==", mode)
        for i_blksize in range(0, nb_blksizes):
            blksize = test_blksizes[i_blksize]
	    _st2 = subtable_where(_st1, 2, "==", blksize)
	    for i_apayload in range(0, nb_apayloads):
                apayload = test_apayloads[i_apayload]
		_st3 = subtable_where(_st2, 7, "==", apayload)
		for i_chksum in range(0, nb_chksums):
                    chksum = test_chksums[i_chksum]
                    _st4 = subtable_where(_st3, 8, "==", chksum)
                    if len(_st4) == 0:
                        continue
                    st = _st4

		    # generate label
		    details = []
		    comments = []
		    if nb_disks > 1:
                        details.append("Disk %d" % (disk))
		    details.append("%s blocks each %d pkt(s)" % (human_readable(blksize, unit="B", infix="i", multiple=1024), st.T[4][0]))
		    if nb_modes > 1:
                        if mode == 1:
                            comments.append("Ind.-I/O")
			else:
                            comments.append("Dir.-I/O")
		    if nb_apayloads > 1:
			    comments.append("Addit. payload: %s" % (comment, human_readable(apayload, unit="B", infix="i", multiple=1024)))
		    if nb_chksums > 1 and chksum >= 1:
			    comments.append("Checksum" % (label, chksum))

		    label = ' '.join(details)
		    if len(comments) > 0:
			    label = "%s\n(%s)" % (label, ', '.join(comments))

                    # derive throughput
		    dps_arr = np.empty(shape=(0, 1), dtype=result.dtype)
		    bitps_arr = np.empty(shape=(0, 1), dtype=result.dtype)
		    for i in range(0, len(st.T[0]) - skip_nb_initial_msmnts - 1):
                        if i >= 1:
                            bps = ((st.T[ 9][i] - st.T[ 9][i - 1]) / st.T[11][i]) # blocks per second
                            pps = ((st.T[10][i] - st.T[10][i - 1]) / st.T[11][i]) # packets per second
                            pps2 = bps * st.T[4][i] # packets per second (2nd way of retrieve it)
                            bitps = pps * st.T[3][i] * 8

                            dps_arr = np.append(dps_arr, bps * blksize)
                            bitps_arr = np.append(bitps_arr, bitps)
                    if len(dps_arr) == 0 or len(bitps_arr) == 0:
                        continue
                    dps_mean   = np.mean(dps_arr)
                    dps_std    = np.std (dps_arr)
                    bitps_mean = np.mean(bitps_arr)
                    bitps_std  = np.std (bitps_arr)

                    ax.bar(left=(bwidth*d),height=dps_mean, width=bwidth, \
                           hatch=hatches[d % len(hatches)], color=colors[d % len(colors)], edgecolor='k', \
                           yerr=dps_std, ecolor='k', capsize=30, \
                           label=label)
                    ax2.bar(left=(bwidth*d),height=bitps_mean, width=bwidth, \
                           fill=False, hatch=' ', edgecolor='k', \
                           yerr=bitps_std, ecolor='k', capsize=30)

                    label = "%s with %s\n%s" % (human_readable(dps_mean, unit="B/s", infix="i", multiple=1024), \
                                                human_readable(bitps_mean, unit="b/s"), label)
                    ax.text((bwidth*d + bwidth/2.), dps_mean,
                            label, ha='center', va='bottom', rotation='vertical')

                    d = d + 1
		    printf(".")
printf("Done\n")
printf("%d data sets plotted\n", d)

printf("Adjusting graph properties...\n")
fig.canvas.mpl_connect('draw_event', mplta_on_draw)
# scale first y-axis (add further 40% space)
(xmin, xmax, ymin, ymax) = ax.axis()
ax.set_ylim((ymin, ymax*1.4))
# scale second y-axis
(xmin, xmax, ymin, ymax) = ax.axis()
ax2.set_ylim((dps2bitps(ymin)), dps2bitps(ymax))

## shrink x-axis by 20%
#box = ax.get_position()
#ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
## put a legend to the right of the x-axis
#ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))

# save files
printf("Writing PDF...\n")
plt.savefig("%s_%s.pdf" % (sys.argv[1], "thrpt-bitps"))
plt.show()
exit(0)
